#include <stdio.h>
int main(void)
{
    char ac[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    char *p = ac;
    char *p1 = &ac[1];
    printf("p=%p\n", p);
    printf("p+1=%p\n", p + 1);     //p+1=p+1*sizeof(char)
    printf("*p+1=%d\n", *(p + 1)); //*(p+1)=ac[1]
    // *(p+n) <-> ac[n];
    printf("p1-p=%d\n", p1 - p); //p1-p=5

    int ai[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int *q = ai;
    int *q1 = &ai[1];
    printf("q=%p\n", q);
    printf("q+1=%p\n", q + 1);     //q+1=q+1*sizeof(int)
    printf("*q+1=%d\n", *(q + 1)); //*(q+1)=ai[1]
    printf("q1-q=%d\n", q1 - q);   //q1-q=5

    return 0;
}

// 指针支持以下算术运算
// 给指针加、减一个整数（+，+=，-，-=）
//递增递减（++ --)
//两个指针相减，结果为16进制内存位置除以sizeof

//*p++
// 取出p所指的那个数据来，完事之后顺便把p移到下一个位置去
// *的优先级虽然高，但是没有++高
// 常用于数组类的连续空间操作
// 在某些cpu上，这可以直接被翻译成一条汇编指令

//指针比较
//<,<=,==,>,>=,!= 都可以对指针做
//比较它们在内存中的地址
//数组中的单元的地址肯定是线性递增的

// 0地址
// 你的内存中有0地址，但是0地址通常是个不能随便碰的地址
// 所以你的指针不应该具有0值
// 因此可以用0地址来表示特殊的事情：
//     返回的指针是无效的
//     指针没有被真正初始化（先初始化为0）
// NULL是一个预定义的符号，表示0地址
//     有的编译器不愿意你用0来表示0地址

// 指针的类型
// 无论指向什么类型，指针的大小都是一样的，因为都是地址
// 但是只想不同类型的指针是不能直接互相赋值的
// 这是为了避免用错指针

// 指针的类型转换
// void *表示不知道指向什么东西的指针
//     计算时与char *相同（但不相通）
// 指针也可以转换类型 
//     int *p = &i;void *q = (void *)p;
// 这并没有改变p所指变量的类型，而是让后人用不同的眼光通过p看它所指的变量
// 我不再当你是int啦，我认为你就是个void！


// 用指针来做什么
// 需要传入较大的数据时用作参数
// 传入数组后对数组做操作
// 函数返回不止一个结果
//     需要函数来修改不止一个变量（swap函数）
// 动态申请的内存...

